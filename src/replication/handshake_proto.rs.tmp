use std::{collections::HashMap, sync::Arc, time::{SystemTime, UNIX_EPOCH}};

use tokio::{io::{AsyncReadExt, AsyncWriteExt}, net::TcpStream, sync::Mutex};

use crate::{
    connection_handling::SharedConnectionHashMapT, 
    errors::RedisErrors, 
    parse_redis_bytes_file::parse_recv_bytes, 
    rdb_persistence::rdb_persist::RDB, 
    redis_key_value_struct::{insert, ValueStruct}, 
    redis_server_info::ServerInfo, 
    replication::replica_info::ReplicaInfo
};


pub async fn handshake(
    _connections: SharedConnectionHashMapT,
    kv_map: Arc<Mutex<HashMap<String, ValueStruct>>>,
    _rdb: Arc<Mutex<RDB>>,
    server_info: Arc<Mutex<ServerInfo>>, 
    replica_info: Arc<Mutex<ReplicaInfo>>
) -> Result<(), RedisErrors> {
    loop {
        {
            // If role is master break.. Master can't perform handshake..
            let replica_info_guard = replica_info.lock().await;
            let role = replica_info_guard.role();
            if role != "slave" {
                println!("Handshake ->>> Master can't perform handshake...");
                break;
            }
        }

        // Get master info
        let (master_host, master_port) = {
            let mut replica_info_guard = replica_info.lock().await;
            match replica_info_guard.slave_info() {
                Some(slave_replica_info) => (
                    slave_replica_info.master_host(),
                    slave_replica_info.master_port()
                ),
                None => {
                    println!("Handshake ->>> No master info configured, sleeping...");
                    tokio::time::sleep(std::time::Duration::from_secs(5)).await;
                    continue;
                }
            }
        };

        let master_addr = format!("{}:{}", master_host, master_port);
        println!("Handshake ->>> Trying to connect to master at {}", master_addr);

        // Try to connect and do handshake
        let server_info1 = Arc::clone(&server_info);
        match first_handshake(server_info1, master_addr.as_str()).await {
            Ok(stream) => {
                println!("Handshake ->>> Connected and handshake complete");

                // Now spawn reader task to listen for master's replication stream
                let kv_map_clone = Arc::clone(&kv_map);
                let reader_task = tokio::spawn(async move {
                    let (mut reader, _) = stream.into_split();
                    let mut buf = [0u8; 1024];
                    loop {
                        match reader.read(&mut buf).await {
                            Ok(0) => {
                                println!("Handshake ->>> Master closed connection");
                                break;
                            }
                            Ok(n) => {
                                if let Ok(cmds) = parse_recv_bytes(&mut buf[..n]).await {
                                    println!("Handshake ->>> Received: {:?}", cmds);
                                    if cmds.get(0).map(|s| s.as_str()) == Some("SET") {
                                        let key = cmds[1].as_str();
                                        let value = cmds[2].as_str();
                                        let mut value_struct = ValueStruct::new(value.to_string(), None, None);
                                        if cmds.len() == 5 {
                                            let px = cmds[4].parse::<u128>().unwrap();
                                            let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
                                            let now_ms = now.as_millis() + px;
                                            value_struct.set_px(Some(px));
                                            value_struct.set_pxat(Some(now_ms));
                                        }
                                        insert(key.to_string(), value_struct, kv_map_clone.clone()).await;
                                    }
                                }
                            }
                            Err(e) => {
                                eprintln!("Handshake ->>> Error reading from master: {}", e);
                                break;
                            }
                        }
                    }
                });

                // Wait for reader_task to finish (i.e. until master connection closes)
                reader_task.await.ok();
                println!("Handshake ->>> Connection to master lost, will retry");
            }
            Err(e) => {
                eprintln!("Handshake ->>> Handshake error: {}", e);
            }
        }

        // Wait before retrying
        tokio::time::sleep(std::time::Duration::from_secs(5)).await;
    }

    Ok(())
}

async fn first_handshake(server_info: Arc<Mutex<ServerInfo>>, master_addr: &str) -> Result<TcpStream, RedisErrors> {
    let mut stream = TcpStream::connect(&master_addr).await?;
        
    let _ = stream.write_all("*1\r\n$4\r\nPING\r\n".as_bytes()).await?;
    // let _ = stream.flush().await;
    // read the incoming message from master server
    let mut buf = [0 as u8; 1024];
    let len = stream.read(&mut buf).await?;
    let message = String::from_utf8_lossy(&buf[..len]);
    println!("First handshake Received: {}", message);
    if message.eq("+PONG\r\n") {
        // second_handshake(_slave_replica_info, master_addr).await?;
        second_handshake(server_info, &mut stream).await?;
    }

    Ok(stream)
}

async fn second_handshake(server_info: Arc<Mutex<ServerInfo>>, stream: &mut TcpStream) -> Result<(), RedisErrors> {
    // let s = format!("*3\r\n$8\r\nREPLCONF\r\n$14\r\nlistening-port\r\n$4\r\n6380\r\n",);
    let mut s = String::new();
    {
        let rep_info_gaurd = server_info.lock().await;
        let form = format!("*3\r\n$8\r\nREPLCONF\r\n$14\r\nlistening-port\r\n$4\r\n{}\r\n", rep_info_gaurd.tcp_port);
        s.push_str(&form);
        
    }
    let _ = stream.write(s.as_bytes()).await?;

    // let _ = stream.write("*3\r\n$8\r\nREPLCONF\r\n$14\r\nlistening-port\r\n$4\r\n6380\r\n".as_bytes()).await?;
    // let _ = stream.flush().await;
    // read the incoming message from master server
    let mut buf = [0 as u8; 1024];
    let len = stream.read(&mut buf).await?;
    let message = String::from_utf8_lossy(&buf[..len]);
    println!("Second handshake Received: {}", message);
    if message.eq("+OK\r\n") {
        third_handshake(server_info, stream).await?;
    }
    Ok(())
}

async fn third_handshake(server_info: Arc<Mutex<ServerInfo>>, stream: &mut TcpStream) -> Result<(), RedisErrors> {
    
    let _ = stream.write("*3\r\n$8\r\nREPLCONF\r\n$4\r\ncapa\r\n$6\r\npsync2\r\n".as_bytes()).await?;
    // let _ = stream.flush().await;
    // read the incoming message from master server
    let mut buf = [0 as u8; 1024];
    let len = stream.read(&mut buf).await?;
    let message = String::from_utf8_lossy(&buf[..len]);
    println!("Third handshake Received: {}", message);
    if message.eq("+OK\r\n") {
        final_handshake(server_info, stream).await?;
    }
    Ok(())
}

async fn final_handshake(_server_info: Arc<Mutex<ServerInfo>>, stream: &mut TcpStream) -> Result<(), RedisErrors> {
    
    let _ = stream.write("*3\r\n$5\r\nPSYNC\r\n$1\r\n?\r\n$2\r\n-1\r\n".as_bytes()).await?;
    // let _ = stream.flush().await;
    // read the incoming message from master server
    let mut buf = [0 as u8; 1024];
    let len = stream.read(&mut buf).await?;
    let message = String::from_utf8_lossy(&buf[..len]);
    println!("Final handshake Received: {}", message);
    
    // get multi-commands
    let mut buf = [0 as u8; 1024];
    let len = stream.read(&mut buf).await?;
    let message = String::from_utf8_lossy(&buf[..len]);
    println!("{:?}",&buf[..len]);
    println!("After final handshake -> Got the file content: {}", message);
    // println!("parbytes: {:?}",parse_recv_bytes(&mut buf).await);
    Ok(())
}